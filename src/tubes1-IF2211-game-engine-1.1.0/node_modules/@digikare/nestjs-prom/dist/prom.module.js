"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var PromModule_1;
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@nestjs/common");
const prom_core_module_1 = require("./prom-core.module");
const interfaces_1 = require("./interfaces");
const prom_providers_1 = require("./prom.providers");
const inbound_middleware_options_1 = require("./middleware/inbound.middleware-options");
const client = require("prom-client");
const prom_controller_1 = require("./prom.controller");
const prom_service_1 = require("./prom.service");
let PromModule = PromModule_1 = class PromModule {
    static forRoot(options = {}) {
        const { withDefaultController, useHttpCounterMiddleware, requestsMetricsOptions: userRequestsMetricsOptions } = options, promOptions = __rest(options, ["withDefaultController", "useHttpCounterMiddleware", "requestsMetricsOptions"]);
        const moduleForRoot = {
            module: PromModule_1,
            imports: [prom_core_module_1.PromCoreModule.forRoot(options)],
            controllers: [],
            exports: [
                prom_service_1.PromService,
            ],
            providers: [
                prom_service_1.PromService,
            ],
        };
        if (withDefaultController !== false) {
            moduleForRoot.controllers = [...moduleForRoot.controllers, prom_controller_1.PromController.forRoot(options.customUrl || 'metrics')];
        }
        if (useHttpCounterMiddleware) {
            const defaultRequestsMetricsOptions = { timeBuckets: client.exponentialBuckets(0.05, 1.75, 8), pathNormalizationExtraMasks: [] };
            const requestsMetricsOptions = userRequestsMetricsOptions ? Object.assign({}, defaultRequestsMetricsOptions, userRequestsMetricsOptions) : defaultRequestsMetricsOptions;
            const additionalProviders = [
                {
                    provide: inbound_middleware_options_1.InboundMiddlewareOptions,
                    useValue: new inbound_middleware_options_1.InboundMiddlewareOptions(options.customUrl || '/metrics', requestsMetricsOptions.pathNormalizationExtraMasks)
                },
                prom_providers_1.createPromCounterProvider({
                    name: "http_requests_total",
                    help: "http_requests_total Number of inbound request",
                    labelNames: ["method", "status", "path"]
                }),
                prom_providers_1.createPromHistogramProvider({
                    name: "http_requests_duration_seconds",
                    help: "Duration of HTTP requests in seconds",
                    labelNames: ["method", "status", "path"],
                    buckets: requestsMetricsOptions.timeBuckets
                })
            ];
            moduleForRoot.providers = [...moduleForRoot.providers, ...additionalProviders];
            moduleForRoot.exports = [...moduleForRoot.exports, ...additionalProviders];
        }
        return moduleForRoot;
    }
    static forMetrics(metrics) {
        const providers = metrics.map((entry) => {
            switch (entry.type) {
                case interfaces_1.MetricType.Counter:
                    return prom_providers_1.createPromCounterProvider(entry.configuration);
                case interfaces_1.MetricType.Gauge:
                    return prom_providers_1.createPromGaugeProvider(entry.configuration);
                case interfaces_1.MetricType.Histogram:
                    return prom_providers_1.createPromHistogramProvider(entry.configuration);
                case interfaces_1.MetricType.Summary:
                    return prom_providers_1.createPromSummaryProvider(entry.configuration);
                default:
                    throw new ReferenceError(`The type ${entry.type} is not supported`);
            }
        });
        return {
            module: PromModule_1,
            providers: providers,
            exports: providers,
        };
    }
    static forCounter(configuration) {
        const provider = prom_providers_1.createPromCounterProvider(configuration);
        return {
            module: PromModule_1,
            providers: [provider],
            exports: [provider],
        };
    }
    static forGauge(configuration) {
        const provider = prom_providers_1.createPromGaugeProvider(configuration);
        return {
            module: PromModule_1,
            providers: [provider],
            exports: [provider],
        };
    }
    static forHistogram(configuration) {
        const provider = prom_providers_1.createPromHistogramProvider(configuration);
        return {
            module: PromModule_1,
            providers: [provider],
            exports: [provider],
        };
    }
    static forSummary(configuration) {
        const provider = prom_providers_1.createPromSummaryProvider(configuration);
        return {
            module: PromModule_1,
            providers: [provider],
            exports: [provider],
        };
    }
};
PromModule = PromModule_1 = __decorate([
    common_1.Module({})
], PromModule);
exports.PromModule = PromModule;
